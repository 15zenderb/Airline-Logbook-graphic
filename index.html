<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Flight Route Animator</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>
  <style>
    :root{ --bg:#0b1220; --card:#0f1724; --muted:#9aa6c0; --accent:#6ee7ff; }
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
    body{display:flex;flex-direction:row;gap:12px;background:linear-gradient(180deg,#071029,#071227);color:#e6eefc}
    .sidebar{width:360px;padding:12px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));box-shadow:0 6px 20px rgba(2,6,23,0.6);overflow:auto}
    h1{margin:6px 0;font-size:18px}
    .controls{display:grid;gap:8px}
    .row{display:flex;gap:8px;align-items:center}
    button{background:#0b2b3a;border:1px solid rgba(255,255,255,0.04);color:var(--accent);padding:8px 10px;border-radius:8px;cursor:pointer}
    input[type=file]{display:none}
    label.file{background:#071722;padding:8px;border-radius:8px;cursor:pointer}
    .small{font-size:12px;color:var(--muted)}
    .filters{display:flex;gap:8px;flex-wrap:wrap}
    .pill{background:rgba(255,255,255,0.02);padding:6px 8px;border-radius:999px;font-size:12px}
    #console{margin-top:8px;background:#031423;padding:8px;border-radius:8px; height:200px; max-height: 200px; overflow:auto; resize: vertical; overflow: auto;}
    .footer{margin-top:10px;font-size:12px;color:var(--muted)}
    .help-modal{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:#071124;padding:18px;border-radius:10px;box-shadow:0 8px 30px rgba(0,0,0,0.6);display:none;z-index:9999;width:720px}
    .help-modal pre{background:#02121b;padding:10px;border-radius:6px;overflow:auto}
    .speed{display:flex;align-items:center;gap:8px}
    .legend{margin-top:8px}
    #map{flex:1;min-height:100vh;position:relative}
    .plane-icon svg{filter:drop-shadow(0 2px 2px rgba(0,0,0,0.6));transform-origin:center center;}
  </style>
</head>
<body>
  <div class="sidebar">
    <h1>Flight Route Animator</h1>
    <div class="controls">
      <div class="row">
        <label class="file">Load Airport DB<input id="airportFile" type="file" accept=".csv" /></label>
        <label class="file">Load Logbook<input id="logbookFile" type="file" accept=".csv" /></label>
        <button id="helpBtn">Help</button>
      </div>

      <div class="row filters">
        <div><input type="checkbox" id="filterAirports" checked> <label for="filterAirports">Airports flown to</label></div>
        <div><input type="checkbox" id="filterAllAirports"> <label for="filterAllAirports">All airports</label></div>
        <div><input type="checkbox" id="filterRoutes" checked> <label for="filterRoutes">Routes</label></div>
      </div>

      <div class="row"> <button id="loadDefaultsBtn">Load Default Data</button></div>

      <div class="row">
        <div style="flex:1">
          <div class="speed small">Speed <input id="speedRange" type="range" min="0.1" max="6" step="0.1" value="1"/> <span id="speedVal">1x</span></div>
        </div>
        <div>
          <button id="playPause">Play</button>
          <button id="resetBtn">Reset</button>
        </div>
      </div>

      <div class="row">
        <div style="flex:1">
          <select id="routeSelect"><option value="">— select a route —</option></select>
        </div>
      </div>
      <div class="pill small" id="routeInfo">Hover a route to see info</div>

      <div class="row">
        <div style="flex:1">
          <div class="speed small">Trail Fade <input id="fadeRange" type="range" min="0.01" max="0.3" step="0.01" value="0.12"/> <span id="fadeVal">0.12</span></div>
        </div>
      </div>

      <div class="row">
      <label for="basemapSelect">Basemap:</label>
      <select id="basemapSelect">
        <option value="dark" selected>Dark</option>
        <option value="osm">OpenStreetMap</option>
        <option value="satellite">Satellite</option>
        <option value="light">Light</option>
      </select>
    </div>

      <div id="console" class="min">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div class="small">Console
            </div>
          </div>
        <div id="log" style="font-family:monospace;font-size:12px;color:#cfeffc;margin-top:6px"></div>
      </div>

      <div class="legend small">
        <div>Tip: load airport DB first. Then load logbook. Use filters to show/hide overlays. Hover routes for counts. Use speed slider to accelerate animation.</div>
      </div>
    </div>
  </div>

  <div id="map"></div>

  <div class="help-modal" id="helpModal">
    <h3>Accepted CSV formats</h3>
    <p class="small">Logbook CSV (tab or comma separated) — header and examples:</p>
    <pre>Date \t Type \t Registration \t Origin \t Destination \t Duration \t Route
12/12/2022\tCRJ9\tN591NN\tKDCA\tKPNS\t2.3\tKDCA KPNS
12/13/2022\tCRJ9\tN599NN\tKPNS\tKDCA\t2.5\tKDCA KPNS</pre>
    <p class="small">Airport DB CSV (standard openflights style). Example first columns:</p>
    <pre>"id","ident","type","name","latitude_deg","longitude_deg",... 
6523,"00A","heliport","Total Rf Heliport",40.0708,-74.9336,...</pre>
    <div style="text-align:right;margin-top:8px"><button id="closeHelp">Close</button></div>
  </div>

  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>

<script>
document.addEventListener('DOMContentLoaded', ()=>{
  function loadLeaflet(callback){
    if(window.L) return callback();
    const s = document.createElement('script');
    s.src = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js';
    s.onload = callback;
    document.head.appendChild(s);
  }

  loadLeaflet(init);

  function init(){
    if(!window.L){ console.error('Leaflet not available'); return; }

    const map = L.map('map',{preferCanvas:true}).setView([39.5,-98.35],4);

    // --- basemap layers ---
    const basemaps = {
      dark: L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png',{
        attribution:'&copy; <a href="https://carto.com/">CARTO</a>',subdomains:'abcd',maxZoom:19
      }),
      osm: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{
        attribution:'&copy; OpenStreetMap contributors', maxZoom:19
      }),
      satellite: L.tileLayer('https://{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}',{
        maxZoom:20, subdomains:['mt0','mt1','mt2','mt3'], attribution:'Google Satellite'
      }),
      light: L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png',{
        attribution:'&copy; <a href="https://carto.com/">CARTO</a>',subdomains:'abcd',maxZoom:19
      })
    };

    // set default basemap
    basemaps.dark.addTo(map);
    let currentBasemap = basemaps.dark;

    setTimeout(()=>{ map.invalidateSize(); }, 100);

    let trailCtx = null, trailCanvasEl = null;
    function createTrailCanvas(){
      const pane = map.getPanes().overlayPane;
      trailCanvasEl = document.createElement('canvas');
      trailCanvasEl.style.position='absolute';
      trailCanvasEl.style.left='0';
      trailCanvasEl.style.top='0';
      trailCanvasEl.style.pointerEvents='none';
      trailCanvasEl.style.background='transparent';
      const s = map.getSize();
      trailCanvasEl.width=s.x; trailCanvasEl.height=s.y;
      pane.appendChild(trailCanvasEl);
      trailCtx=trailCanvasEl.getContext('2d');
      trailCtx.globalCompositeOperation='source-over';
      map.on('resize', ()=>{ const ss=map.getSize(); trailCanvasEl.width=ss.x; trailCanvasEl.height=ss.y; });
    }
    map.whenReady(()=>{ createTrailCanvas(); });
    const defaultAirportDBPath = "https://raw.githubusercontent.com/15zenderb/Airline-Logbook-graphic/main/data/airports.csv";
    const defaultLogbookPath = "https://raw.githubusercontent.com/15zenderb/Airline-Logbook-graphic/main/data/Airline%20chart%20data.csv";
    const airports = {}; 
    let routes = {}; 
    let flights = []; 
    let running=false; 
    let speedMult=1; 
    let trailFade=0.12;
    let airportMarkers=[]; 
    let flightAirportsMarkers=[];
    let routeLayers = {}; // holds current polylines so we can clear them safely


    const logEl = document.getElementById('log');
    function log(...args){
      const s = args.join(' ');
      const d = new Date().toLocaleTimeString();
      const div = document.createElement('div');
      div.textContent = `[${d}] ${s}`;
      logEl.prepend(div);
      if(logEl.childNodes.length > 100) logEl.removeChild(logEl.lastChild);
    }

    document.getElementById('helpBtn').onclick = ()=>{document.getElementById('helpModal').style.display='block'};
    document.getElementById('closeHelp').onclick = ()=>{document.getElementById('helpModal').style.display='none'};
    document.getElementById('speedRange').oninput = e=>{ speedMult=parseFloat(e.target.value); document.getElementById('speedVal').textContent=speedMult.toFixed(1)+"x"; }
    document.getElementById('fadeRange').oninput = e=>{ trailFade=parseFloat(e.target.value); document.getElementById('fadeVal').textContent=trailFade; }
    document.getElementById('playPause').onclick = ()=>{running=!running; document.getElementById('playPause').textContent=running?'Pause':'Play'; if(running) requestAnimationFrame(loop);}
    document.getElementById('resetBtn').onclick = ()=>{ resetAnimation(); }
    document.getElementById('airportFile').addEventListener('change', e=>{ const f=e.target.files[0]; if(!f) return; parseAirportCSV(f); });
    document.getElementById('logbookFile').addEventListener('change', e=>{ const f=e.target.files[0]; if(!f) return; parseLogbookCSV(f); });
    document.getElementById('basemapSelect').addEventListener('change', e => {
      const val = e.target.value;
      if(currentBasemap) map.removeLayer(currentBasemap);
      if(basemaps[val]){
        currentBasemap = basemaps[val];
        currentBasemap.addTo(map);
      }
    });

    document.getElementById("loadDefaultsBtn").addEventListener("click", loadDefaults);

    // Auto-load on page open
    window.addEventListener("load", loadDefaults);


    // Filter toggles
    document.getElementById('filterAllAirports').onchange = e=>{ 
      if(e.target.checked) drawAllAirports(); 
      else airportMarkers.forEach(m=>map.removeLayer(m)); 
    };
    document.getElementById('filterAirports').onchange = e => {
      if (e.target.checked) drawFlightAirports();
      else flightAirportsMarkers.forEach(m => map.removeLayer(m));
    };
    document.getElementById('filterRoutes').onchange = e=>{ 
      Object.values(routes).forEach(r=>{ 
        if(r.polyline) map.removeLayer(r.polyline); 
        if(e.target.checked && r.polyline) r.polyline.addTo(map); 
      }); 
    };
    document.getElementById('routeSelect').onchange = e=>{ 
      const val=e.target.value; 
      if(val&&routes[val]){
        flights=[]; 
        flights.push({id:0,origin:routes[val].origin,destination:routes[val].destination,duration:0,progress:0}); 
        startFlights(); 
      }
    };

    // === helpers for code normalization & lookup ===
    function normalizeCode(s){ return s ? s.toString().trim().toUpperCase() : ''; }
    function findAirportForCode(code){
      const c = normalizeCode(code);
      if(!c) return { key: c, airport: null };
      if(airports[c]) return { key: c, airport: airports[c] };
      if(c.length === 3 && airports['K' + c]) return { key: 'K' + c, airport: airports['K' + c] };
      if(c.length === 4 && c.startsWith('K') && airports[c.slice(1)]) return { key: c.slice(1), airport: airports[c.slice(1)] };
      return { key: c, airport: null };
    }

    // === CSV parsing ===
    function parseAirportCSV(file){
      Papa.parse(file, {
        header: true,
        skipEmptyLines: true,
        complete: function(results) {
          let count = 0;
          results.data.forEach((row, idx) => {
            const ident = (row.ident || row.IDENT || row.ICAO || row.icao || '').toString().trim();
            const iata = (row.iata_code || row.IATA || row.iata || '').toString().trim();
            const gps  = (row.gps_code || row.GPS || row.gps || '').toString().trim();
            const local= (row.local_code || row.local || '').toString().trim();

            const lat = parseFloat(row.latitude_deg || row.latitude || row.Lat || row.lat);
            const lon = parseFloat(row.longitude_deg || row.longitude || row.Lon || row.lon);
            const name = row.name || row.Name || row.municipality || '';

            if (!isNaN(lat) && !isNaN(lon)) {
              const airportObj = { lat, lng: lon, name };
              if (ident) airports[ident.toUpperCase()] = airportObj;
              if (iata)  airports[iata.toUpperCase()]  = airportObj;
              if (gps)   airports[gps.toUpperCase()]   = airportObj;
              if (local) airports[local.toUpperCase()] = airportObj;
              if (!ident && row.id) airports[String(row.id)] = airportObj;
              count++;
            }
          });
          log(`Loaded ${count} airports from ${file.name}`);
          if (document.getElementById('filterAllAirports').checked) drawAllAirports();
          if (document.getElementById('filterAirports').checked) drawFlightAirports();
        }
      });
    }

    function parseLogbookCSV(file){
      Papa.parse(file,{header:true,skipEmptyLines:true,complete:function(results){
        routes = {}; flights = [];
        results.data.forEach((r, idx) => {
          const originRaw = (r.Origin || r.origin || r.ORIGIN || '').toString().trim();
          const destinationRaw = (r.Destination || r.destination || r.DESTINATION || '').toString().trim();
          const duration = parseFloat(r.Duration || r.duration || r.DURATION || 0) || 0;
          if (!originRaw || !destinationRaw) return;

          const o = findAirportForCode(originRaw);
          const d = findAirportForCode(destinationRaw);

          if (!o.airport || !d.airport) {
            log(`[Warning] Missing airport for flight ${originRaw} → ${destinationRaw} (resolved: ${o.key} / ${d.key})`);
          }

          const key = `${o.key} ${d.key}`;
          if (!routes[key]) routes[key] = { count: 0, samples: [], flights: [], origin: o.key, destination: d.key };
          routes[key].count++; routes[key].samples.push(duration);
          flights.push({ id: idx, origin: o.key, destination: d.key, duration, progress: 0 });
        });
        buildRouteOverlays(); populateRouteSelect();
        log(`Loaded ${results.data.length} flights from ${file.name} (${Object.keys(routes).length} unique routes)`);
        if (document.getElementById('filterAirports').checked) drawFlightAirports();
      }});
    }

    // === Drawing ===
    function drawAllAirports() {
      airportMarkers.forEach(m => map.removeLayer(m));
      airportMarkers = [];
      Object.values(airports).forEach(a => {
        if (!a) return;
        const m = L.circleMarker([a.lat, a.lng], {radius:3, fill:true, fillOpacity:0.8})
                  .bindPopup(a.name || '')
                  .addTo(map);
        airportMarkers.push(m);
      });
    }

    function drawFlightAirports(){
      flightAirportsMarkers.forEach(m=>map.removeLayer(m)); 
      flightAirportsMarkers=[];
      const added = new Set();
      Object.values(routes).forEach(r=>{
        [r.origin, r.destination].forEach(code=>{
          if (!code || added.has(code)) return;
          const a=airports[code];
          if(a){ 
            flightAirportsMarkers.push(L.circleMarker([a.lat,a.lng],{radius:4,fill:true,fillOpacity:0.8}).addTo(map)); 
            added.add(code);
          }
        });
      });
    }


    /*Building routes*/
    
    function buildRouteOverlays(){
      // remove any previous route layers
      try {
        Object.values(routeLayers).forEach(layer => { if (layer && map.hasLayer(layer)) map.removeLayer(layer); });
      } catch(e){ /* ignore */ }
      routeLayers = {};

      // also clear any r.polyline left on routes (backwards compatibility)
      Object.values(routes).forEach(r => { if (r && r.polyline && map.hasLayer(r.polyline)) { map.removeLayer(r.polyline); } r.polyline = null; });

      // gather frequency list
      const freqs = Object.values(routes).map(r => Number(r.count || 0)).filter(n => !Number.isNaN(n));
      if (freqs.length === 0) return;

      const minF = Math.min(...freqs);
      const maxF = Math.max(...freqs);
      const denom = (maxF - minF) || 1;

      // color ramp: cyan -> yellow -> red via hue interpolation
      function getColorForFreq(f){
        const t = (f - minF) / denom; // 0..1
        const hue = 200 - t * 180;     // 200 (cyan) down to ~20 (orange/red)
        const sat = 85;
        const light = 55 - t * 18;     // slightly darker for high freq
        return `hsl(${hue},${sat}%,${light}%)`;
      }
      // weight scaling: more frequent => thicker
      function getWeightForFreq(f){
        const t = (f - minF) / denom;
        return 1 + t * 6; // 1px -> ~7px
      }

      Object.keys(routes).forEach(key => {
        const r = routes[key];
        if(!r) return;
        const a = airports[r.origin];
        const b = airports[r.destination];
        if(!a || !b) { r.polyline = null; return; }

        // create curved great-circle arc (returns array of [lat,lng])
        const arcCoords = createGreatCircleArc([a.lat, a.lng], [b.lat, b.lng], 64);

        const color = getColorForFreq(r.count || 0);
        const weight = getWeightForFreq(r.count || 0);

        const poly = L.polyline(arcCoords, {
          color,
          weight,
          opacity: 0.9,
          smoothFactor: 1
        }).addTo(map);

        // hover styling + tooltip
        poly.on('mouseover', () => {
          poly.setStyle({ weight: Math.min(weight + 4, 16), opacity: 1 });
          showRouteTooltip(r, poly);
        });
        poly.on('mouseout', () => {
          poly.setStyle({ weight, opacity: 0.9, color });
          hideRouteTooltip(poly);
        });

        poly.bindTooltip(`${r.origin} → ${r.destination}<br/>${r.count} flights`, { direction: 'auto' });

        // keep references both in routeLayers and on the route object (backwards compat)
        routeLayers[key] = poly;
        r.polyline = poly;
      });
    }

    // Great-circle arc generator: returns array of [lat,lng] points
    function createGreatCircleArc(start, end, numPoints = 64){
      const lat1 = start[0] * Math.PI / 180;
      const lon1 = start[1] * Math.PI / 180;
      const lat2 = end[0] * Math.PI / 180;
      const lon2 = end[1] * Math.PI / 180;

      // central angle
      const d = 2 * Math.asin(Math.sqrt(
        Math.sin((lat1 - lat2) / 2) ** 2 +
        Math.cos(lat1) * Math.cos(lat2) * Math.sin((lon1 - lon2) / 2) ** 2
      ));

      if (!d || Number.isNaN(d)) return [[start[0], start[1]], [end[0], end[1]]];

      const coords = [];
      for (let i = 0; i <= numPoints; i++){
        const f = i / numPoints;
        const A = Math.sin((1 - f) * d) / Math.sin(d);
        const B = Math.sin(f * d) / Math.sin(d);

        const x = A * Math.cos(lat1) * Math.cos(lon1) + B * Math.cos(lat2) * Math.cos(lon2);
        const y = A * Math.cos(lat1) * Math.sin(lon1) + B * Math.cos(lat2) * Math.sin(lon2);
        const z = A * Math.sin(lat1) + B * Math.sin(lat2);

        const lat = Math.atan2(z, Math.sqrt(x * x + y * y)) * 180 / Math.PI;
        const lon = Math.atan2(y, x) * 180 / Math.PI;
        coords.push([lat, lon]);
      }
      return coords;
    }


/*Done building routes*/

    function showRouteTooltip(r,poly){
      const el=document.getElementById('routeInfo');
      const avg=(r.samples.reduce((a,b)=>a+b,0)/r.samples.length||0).toFixed(2);
      el.textContent=`${r.origin} → ${r.destination} • ${r.count} flights • avg ${avg}h`;
      try{ poly.bindPopup(`${r.origin} → ${r.destination}<br/>Flights: ${r.count}<br/>Avg duration: ${avg}h`).openPopup(); }catch(e){}
    }
    function hideRouteTooltip(poly){ try{poly.closePopup()}catch(e){} }

    function populateRouteSelect(){
      const sel=document.getElementById('routeSelect'); 
      sel.innerHTML=''; 
      const opt=document.createElement('option'); 
      opt.value=''; 
      opt.textContent='— select a route —'; 
      sel.appendChild(opt);
      Object.keys(routes).forEach(k=>{ 
        const r=routes[k]; 
        const o=document.createElement('option'); 
        o.value=k; 
        o.textContent=`${r.origin} → ${r.destination} (${r.count})`; 
        sel.appendChild(o); 
      });
    }

    let activePlanes=[];
    function startFlights(){
      activePlanes.length=0;
      const maxPlanes=Math.min(flights.length,200);
      for(let i=0;i<maxPlanes;i++){
        const f=flights[i]; const a=airports[f.origin]; const b=airports[f.destination]; if(!a||!b) continue;
        const latlngs=[L.latLng(a.lat,a.lng),L.latLng(b.lat,b.lng)];
        const totalSteps=600;
        const plane={id:f.id,latlngs,step:0,total:totalSteps,marker:createPlaneMarker(latlngs[0],latlngs[1]),trail:[]};
        plane.marker.addTo(map);
        activePlanes.push(plane);
      }
      if(activePlanes.length===0){ log('No valid flights to animate (check airport DB vs logbook)'); return; }
      running=true; document.getElementById('playPause').textContent='Pause'; requestAnimationFrame(loop);
    }

    function resetAnimation(){
      activePlanes.forEach(p=>{ try{map.removeLayer(p.marker);}catch(e){} });
      activePlanes.length=0; clearTrails(); running=false; document.getElementById('playPause').textContent='Play';
    }

    function createPlaneMarker(start,end){
      const svg=`<?xml version='1.0'?><svg xmlns='http://www.w3.org/2000/svg' width='30' height='30' viewBox='0 0 24 24'><path fill='white' d='M21 16v-2l-8-5V3.5a1.5 1.5 0 0 0-3 0 .5V9l-8 5v2l8-2.5V21l2-1 2 1v-7.5l8 2.5z'/></svg>`;
      const icon = L.divIcon({ className:'plane-icon', html:svg, iconSize:[30,30], iconAnchor:[15,15] });
      return L.marker(start,{icon});
    }

    function clearTrails(){
      if(trailCtx){
        trailCtx.clearRect(0,0,trailCanvasEl.width,trailCanvasEl.height);
      }
    }

    function loop(){
      if(!running) return;
      if(trailCtx){
        trailCtx.fillStyle=`rgba(0,0,0,${trailFade})`;
        trailCtx.fillRect(0,0,trailCanvasEl.width,trailCanvasEl.height);
      }
      activePlanes.forEach(p=>{
        p.step+=speedMult;
        const frac = Math.min(p.step/p.total,1);
        const lat = p.latlngs[0].lat + frac*(p.latlngs[1].lat - p.latlngs[0].lat);
        const lng = p.latlngs[0].lng + frac*(p.latlngs[1].lng - p.latlngs[0].lng);
        const pos=[lat,lng];
        p.marker.setLatLng(pos);
        const angle = Math.atan2(p.latlngs[1].lng - p.latlngs[0].lng, p.latlngs[1].lat - p.latlngs[0].lat)*180/Math.PI;
        p.marker.getElement().style.transform=`rotate(${angle}deg)`;
        if(trailCtx){
          const point = map.latLngToContainerPoint(pos);
          trailCtx.fillStyle='rgba(110,231,255,0.8)';
          trailCtx.beginPath();
          trailCtx.arc(point.x,point.y,2,0,Math.PI*2);
          trailCtx.fill();
        }
        if(frac>=1) p.step=0;
      });
      requestAnimationFrame(loop);
    }

    // Auto-load defaults when the page finishes loading

    window.addEventListener("load", loadDefaults);

  function loadDefaults(){
    console.log("Loading default airports and logbook...");

    const defaultAirportDBPath = "https://raw.githubusercontent.com/15zenderb/Airline-Logbook-graphic/main/data/airports.csv";
    const defaultLogbookPath   = "https://raw.githubusercontent.com/15zenderb/Airline-Logbook-graphic/main/data/Airline%20chart%20data.csv";

    // --- load airports ---
    Papa.parse(defaultAirportDBPath, {
      download: true,
      header: true,
      complete: function(results){
        // clear existing airports
        Object.keys(airports).forEach(k => delete airports[k]);

        results.data.forEach(a => {
          if(a.ICAO) airports[a.ICAO.toUpperCase()] = {
            lat: parseFloat(a.Lat),
            lng: parseFloat(a.Lon),
            name: a.Name
          };
        });

        console.log("Default airport DB loaded:", Object.keys(airports).length);
        if(document.getElementById('filterAllAirports').checked) drawAllAirports();
        if(document.getElementById('filterAirports').checked) drawFlightAirports();
      }
    });

    // --- load logbook ---
    Papa.parse(defaultLogbookPath, {
      download: true,
      header: true,
      complete: function(results){
        flights.length = 0;
        routes = {};

        results.data.forEach(f => {
          const route = f["Route of Flight"]?.split("-") || [];
          const origin = route[0]?.trim();
          const destination = route[1]?.trim();
          if(!origin || !destination) return;

          flights.push({
            origin,
            destination,
            date: f.Date,
            progress: 0
          });

          const key = `${origin} ${destination}`;
          if(!routes[key]) routes[key] = { count: 0, samples: [], flights: [], origin, destination };
          routes[key].count++;
          routes[key].samples.push(0); // duration placeholder
        });

        console.log("Default logbook loaded:", flights.length);
        buildRouteOverlays();
        populateRouteSelect();
        if(document.getElementById('filterAirports').checked) drawFlightAirports();
      }
    });
  }

}


});
</script>

</body>
</html>
